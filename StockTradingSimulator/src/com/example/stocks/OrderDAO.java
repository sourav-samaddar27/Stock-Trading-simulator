// OrderDAO.java
package com.example.stocks; // Package declaration.

import java.sql.Connection;        // Represents a connection to a database.
import java.sql.PreparedStatement; // Used for executing precompiled SQL statements (safer and faster).
import java.sql.ResultSet;         // Represents a table of data generated by executing a query.
import java.sql.SQLException;      // Handles database access errors.
import java.sql.Statement;         // Used for executing simple SQL statements.
import java.sql.Timestamp;         // For converting LocalDateTime to/from SQL TIMESTAMP.
import java.math.BigDecimal;       // For handling monetary values.
import java.time.LocalDateTime;    // For handling order timestamps.
import java.util.ArrayList;        // For returning lists of orders.
import java.util.List;             // For returning lists of orders.
import java.util.Optional;         // For methods that might return no result.

/**
 * Data Access Object (DAO) for the Order entity.
 * This class provides methods to perform CRUD (Create, Read, Update, Delete)
 * operations on the 'Orders' table in the database.
 */
public class OrderDAO {

    /**
     * Saves a new order to the database.
     * The order's ID and timestamp will be auto-generated by the database.
     *
     * @param order The Order object to save.
     * @return The saved Order object with the database-generated ID and timestamp.
     * @throws SQLException If a database access error occurs.
     */
    public Order save(Order order) throws SQLException {
        // SQL INSERT statement. 'id' and 'timestamp' are omitted as they are AUTO_INCREMENT/DEFAULT CURRENT_TIMESTAMP.
        String sql = "INSERT INTO Orders (user_id, stock_id, order_type, price, quantity, status) VALUES (?, ?, ?, ?, ?, ?)";

        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            stmt.setInt(1, order.getUserId());
            stmt.setInt(2, order.getStockId());
            stmt.setString(3, order.getOrderType().name()); // Convert enum to String for DB storage.
            stmt.setBigDecimal(4, order.getPrice());
            stmt.setInt(5, order.getQuantity());
            stmt.setString(6, order.getStatus().name()); // Convert enum to String for DB storage.

            int affectedRows = stmt.executeUpdate();
            if (affectedRows == 0) {
                throw new SQLException("Creating order failed, no rows affected.");
            }

            // Retrieve auto-generated ID and timestamp.
            // A robust way to get the timestamp is to fetch the full object again by ID.
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    int id = generatedKeys.getInt(1); // Get the auto-generated ID.
                    Optional<Order> fetchedOrder = findById(id);
                    if (fetchedOrder.isPresent()) {
                        return fetchedOrder.get();
                    } else {
                        throw new SQLException("Creating order failed, could not retrieve full object after insert.");
                    }
                } else {
                    throw new SQLException("Creating order failed, no ID obtained.");
                }
            }
        }
    }

    /**
     * Finds an order by its ID.
     *
     * @param id The ID to search for.
     * @return An Optional containing the Order object if found, otherwise an empty Optional.
     * @throws SQLException If a database access error occurs.
     */
    public Optional<Order> findById(int id) throws SQLException {
        String sql = "SELECT id, user_id, stock_id, order_type, price, quantity, status, timestamp FROM Orders WHERE id = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, id);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return Optional.of(mapResultSetToOrder(rs)); // Helper method to map ResultSet row to Order object.
                }
            }
        }
        return Optional.empty();
    }

    /**
     * Finds all pending BUY orders for a specific stock, ordered by price (highest first).
     * This is crucial for the OrderMatchingEngine.
     *
     * @param stockId The ID of the stock.
     * @return A List of pending BUY Order objects.
     * @throws SQLException If a database access error occurs.
     */
    public List<Order> findPendingBuyOrdersByStockId(int stockId) throws SQLException {
        List<Order> orders = new ArrayList<>();
        // CRITICAL SPACE: Ensure there's a space after "Orders " before "WHERE"
        String sql = "SELECT id, user_id, stock_id, order_type, price, quantity, status, timestamp FROM Orders " +
                "WHERE stock_id = ? AND order_type = ? AND status = ? ORDER BY price DESC";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, stockId);
            stmt.setString(2, Order.OrderType.BUY.name());
            stmt.setString(3, Order.OrderStatus.PENDING.name());

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    orders.add(mapResultSetToOrder(rs));
                }
            }
        }
        return orders;
    }

    /**
     * Finds all pending SELL orders for a specific stock, ordered by price (lowest first).
     * This is crucial for the OrderMatchingEngine.
     *
     * @param stockId The ID of the stock.
     * @return A List of pending SELL Order objects.
     * @throws SQLException If a database access error occurs.
     */
    public List<Order> findPendingSellOrdersByStockId(int stockId) throws SQLException {
        List<Order> orders = new ArrayList<>();
        // CRITICAL SPACE: Ensure there's a space after "Orders " before "WHERE"
        String sql = "SELECT id, user_id, stock_id, order_type, price, quantity, status, timestamp FROM Orders " +
                "WHERE stock_id = ? AND order_type = ? AND status = ? ORDER BY price ASC";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, stockId);
            stmt.setString(2, Order.OrderType.SELL.name());
            stmt.setString(3, Order.OrderStatus.PENDING.name());

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    orders.add(mapResultSetToOrder(rs));
                }
            }
        }
        return orders;
    }

    /**
     * Finds all orders placed by a specific user.
     * This method is added to support displaying a user's order history.
     *
     * @param userId The ID of the user whose orders to retrieve.
     * @return A List of Order objects placed by the specified user.
     * @throws SQLException If a database access error occurs.
     */
    public List<Order> findOrdersByUserId(int userId) throws SQLException {
        List<Order> orders = new ArrayList<>();
        // CRITICAL SPACE: Ensure there's a space after "Orders " before "WHERE"
        String sql = "SELECT id, user_id, stock_id, order_type, price, quantity, status, timestamp FROM Orders " +
                "WHERE user_id = ? ORDER BY timestamp DESC"; // Order by most recent orders first.
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, userId); // Set the user ID parameter.

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    orders.add(mapResultSetToOrder(rs));
                }
            }
        }
        return orders;
    }

    /**
     * Updates an existing order's status and remaining quantity in the database.
     * This is crucial for the OrderMatchingEngine to reflect trade execution.
     *
     * @param order The Order object with the updated status and quantity (ID must be set).
     * @return true if the order was updated successfully, false otherwise.
     * @throws SQLException If a database access error occurs.
     */
    public boolean updateStatusAndQuantity(Order order) throws SQLException {
        String sql = "UPDATE Orders SET status = ?, quantity = ? WHERE id = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setString(1, order.getStatus().name()); // Update status.
            stmt.setInt(2, order.getQuantity());        // Update remaining quantity.
            stmt.setInt(3, order.getId());               // Identify order by ID.

            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        }
    }

    /**
     * Helper method to map a ResultSet row to an Order object.
     * Centralizes the logic for creating an Order from database data.
     *
     * @param rs The ResultSet containing the current row's data.
     * @return An Order object.
     * @throws SQLException If a database access error occurs during data retrieval.
     */
    private Order mapResultSetToOrder(ResultSet rs) throws SQLException {
        int id = rs.getInt("id");
        int userId = rs.getInt("user_id");
        int stockId = rs.getInt("stock_id");
        Order.OrderType orderType = Order.OrderType.valueOf(rs.getString("order_type")); // Convert String from DB back to enum.
        BigDecimal price = rs.getBigDecimal("price");
        int quantity = rs.getInt("quantity");
        Order.OrderStatus status = Order.OrderStatus.valueOf(rs.getString("status"));   // Convert String from DB back to enum.
        Timestamp timestampSql = rs.getTimestamp("timestamp"); // Get as SQL Timestamp.
        LocalDateTime timestamp = timestampSql != null ? timestampSql.toLocalDateTime() : null; // Convert to LocalDateTime.

        return new Order(id, userId, stockId, orderType, price, quantity, status, timestamp);
    }
}
