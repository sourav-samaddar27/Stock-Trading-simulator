// StockDAO.java
package com.example.stocks; // Package declaration.

import java.sql.Connection;        // Represents a connection to a database.
import java.sql.PreparedStatement; // Used for executing precompiled SQL statements (safer and faster).
import java.sql.ResultSet;         // Represents a table of data generated by executing a query.
import java.sql.SQLException;      // Handles database access errors.
import java.sql.Statement;         // Used for executing simple SQL statements.
import java.math.BigDecimal;       // For handling monetary values.
import java.util.ArrayList;        // For returning lists of stocks.
import java.util.List;             // For returning lists of stocks.
import java.util.Optional;         // For methods that might return no result.

/**
 * Data Access Object (DAO) for the Stock entity.
 * This class provides methods to perform CRUD (Create, Read, Update, Delete)
 * operations on the 'Stocks' table in the database.
 */
public class StockDAO {

    /**
     * Saves a new stock to the database.
     * The stock's ID will be auto-generated by the database.
     *
     * @param stock The Stock object to save.
     * @return The saved Stock object with the database-generated ID.
     * @throws SQLException If a database access error occurs or the stock symbol already exists.
     */
    public Stock save(Stock stock) throws SQLException {
        // SQL INSERT statement. 'id' is omitted as it's AUTO_INCREMENT.
        // We use placeholders (?) for values to prevent SQL Injection (PreparedStatement).
        String sql = "INSERT INTO Stocks (symbol, company_name, current_price) VALUES (?, ?, ?)";

        // Use try-with-resources for Connection and PreparedStatement to ensure they are closed.
        try (Connection connection = DatabaseManager.getConnection(); // Get a connection from DatabaseManager.
             // Prepare the statement. Statement.RETURN_GENERATED_KEYS is important to get the auto-generated ID.
             PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            // Set the values for the placeholders in the SQL statement.
            // Parameters are 1-indexed in JDBC.
            stmt.setString(1, stock.getSymbol());
            stmt.setString(2, stock.getCompanyName());
            stmt.setBigDecimal(3, stock.getCurrentPrice());

            int affectedRows = stmt.executeUpdate(); // Execute the INSERT statement.
            // executeUpdate() returns the number of rows affected.
            if (affectedRows == 0) {
                // If no rows were affected, it means the insert failed for some reason.
                throw new SQLException("Creating stock failed, no rows affected.");
            }

            // Retrieve the auto-generated ID.
            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                if (generatedKeys.next()) { // Move the cursor to the first (and only) generated key.
                    int id = generatedKeys.getInt(1); // Get the integer value of the first generated key.
                    // Create a new Stock object with the database-assigned ID.
                    // This is why we need the constructor that takes 'id'.
                    return new Stock(id, stock.getSymbol(), stock.getCompanyName(), stock.getCurrentPrice());
                } else {
                    throw new SQLException("Creating stock failed, no ID obtained.");
                }
            }
        } // Connection and PreparedStatement are automatically closed here.
    }

    /**
     * Finds a stock by its symbol.
     *
     * @param symbol The stock symbol to search for (e.g., "AAPL").
     * @return An Optional containing the Stock object if found, otherwise an empty Optional.
     * @throws SQLException If a database access error occurs.
     */
    public Optional<Stock> findBySymbol(String symbol) throws SQLException {
        // Corrected SQL: Ensure space before WHERE
        String sql = "SELECT id, symbol, company_name, current_price FROM Stocks WHERE symbol = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setString(1, symbol); // Set the symbol parameter.

            try (ResultSet rs = stmt.executeQuery()) { // Execute the SELECT query.
                if (rs.next()) { // If a row is returned (stock found).
                    int id = rs.getInt("id"); // Get data by column name.
                    String foundSymbol = rs.getString("symbol");
                    String companyName = rs.getString("company_name");
                    BigDecimal currentPrice = rs.getBigDecimal("current_price");
                    return Optional.of(new Stock(id, foundSymbol, companyName, currentPrice)); // Return Stock in Optional.
                }
            }
        }
        return Optional.empty(); // Return empty Optional if no stock found.
    }

    /**
     * Finds a stock by its ID.
     *
     * @param id The ID to search for.
     * @return An Optional containing the Stock object if found, otherwise an empty Optional.
     * @throws SQLException If a database access error occurs.
     */
    public Optional<Stock> findById(int id) throws SQLException {
        // Corrected SQL: Ensure space before WHERE
        String sql = "SELECT id, symbol, company_name, current_price FROM Stocks WHERE id = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, id); // Set the ID parameter.

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int foundId = rs.getInt("id");
                    String symbol = rs.getString("symbol");
                    String companyName = rs.getString("company_name");
                    BigDecimal currentPrice = rs.getBigDecimal("current_price");
                    return Optional.of(new Stock(foundId, symbol, companyName, currentPrice));
                }
            }
        }
        return Optional.empty();
    }

    /**
     * Retrieves all stocks from the database.
     *
     * @return A List of all Stock objects.
     * @throws SQLException If a database access error occurs.
     */
    public List<Stock> findAll() throws SQLException {
        List<Stock> stocks = new ArrayList<>();
        // Corrected SQL: Ensure space before ORDER BY
        String sql = "SELECT id, symbol, company_name, current_price FROM Stocks ORDER BY symbol";         try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) { // Execute the SELECT query.

            while (rs.next()) { // Iterate through each row in the ResultSet.
                int id = rs.getInt("id");
                String symbol = rs.getString("symbol");
                String companyName = rs.getString("company_name");
                BigDecimal currentPrice = rs.getBigDecimal("current_price");
                stocks.add(new Stock(id, symbol, companyName, currentPrice)); // Add new Stock object to list.
            }
        }
        return stocks; // Return the list of stocks.
    }

    /**
     * Updates an existing stock's current price in the database.
     * This is crucial for the MarketDataSimulator.
     *
     * @param stock The Stock object with the updated price (ID must be set).
     * @return true if the stock was updated successfully, false otherwise.
     * @throws SQLException If a database access error occurs.
     */
    public boolean updatePrice(Stock stock) throws SQLException {
        String sql = "UPDATE Stocks SET current_price = ? WHERE id = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setBigDecimal(1, stock.getCurrentPrice()); // Set the new price.
            stmt.setInt(2, stock.getId());                  // Set the stock ID for the WHERE clause.

            int affectedRows = stmt.executeUpdate(); // Execute the UPDATE statement.
            return affectedRows > 0; // Returns true if one or more rows were updated.
        }
    }

    /**
     * Deletes a stock from the database by ID.
     *
     * @param id The ID of the stock to delete.
     * @return true if the stock was deleted successfully, false otherwise.
     * @throws SQLException If a database access error occurs.
     */
    public boolean delete(int id) throws SQLException {
        String sql = "DELETE FROM Stocks WHERE id = ?";
        try (Connection connection = DatabaseManager.getConnection();
             PreparedStatement stmt = connection.prepareStatement(sql)) {

            stmt.setInt(1, id); // Set the ID parameter.

            int affectedRows = stmt.executeUpdate(); // Execute the DELETE statement.
            return affectedRows > 0; // Returns true if one or more rows were deleted.
        }
    }
}
